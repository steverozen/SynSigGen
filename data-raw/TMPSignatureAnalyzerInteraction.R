# SignatureAnalyzerInteraction.R

#' Standardize SignatureAnalyzer signature names
#'
#' For example, change \code{BI_COMPOSITE_SNV_SBS83_P}
#' to \code{BI_COMPOSITE_SBS83_P}
#'
#' This is necessary because
#' for COMPOSITE signatures we rbind coordinated
#' "SNV", "DNP", and "INDEL" signatures.
#'
#' @param sig.names Vector of signature names
#'
#' @return Vector of signatures names with "_SNV" removed.
#'
#' @export

FixSASigNames <- function(sig.names) {
  return(gsub("_SNV_", "_", sig.names, fixed = TRUE))
}


#' Prepare input data for SignatureAnalyzer
#'
#' @param cat96 Input catalog in in standard in-memory format
#'
#' @return Catalog in in-memory format expected by SignatureAnalyzer
#'
#' @keywords internal

SACat96 <- function(cat96) {
  stopifnot(nrow(cat96) == 96)
  SA.96.row.order <-
    c("TGTT", "TGGT", "TGCT", "TGAT", "TGTG", "TGGG", "TGCG", "TGAG",
      "TGTC", "TGGC", "TGCC", "TGAC", "TGTA", "TGGA", "TGCA", "TGAA",
      "TCTT", "TCGT", "TCCT", "TCAT", "TCTG", "TCGG", "TCCG", "TCAG",
      "TCTC", "TCGC", "TCCC", "TCAC", "TCTA", "TCGA", "TCCA", "TCAA",
      "TATT", "TAGT", "TACT", "TAAT", "TATG", "TAGG", "TACG", "TAAG",
      "TATC", "TAGC", "TACC", "TAAC", "TATA", "TAGA", "TACA", "TAAA",
      "CAAA", "CAAC", "CAAG", "CAAT", "CACA", "CACC", "CACG", "CACT",
      "CAGA", "CAGC", "CAGG", "CAGT", "CATA", "CATC", "CATG", "CATT",
      "CGAA", "CGAC", "CGAG", "CGAT", "CGCA", "CGCC", "CGCG", "CGCT",
      "CGGA", "CGGC", "CGGG", "CGGT", "CGTA", "CGTC", "CGTG", "CGTT",
      "CTAA", "CTAC", "CTAG", "CTAT", "CTCA", "CTCC", "CTCG", "CTCT",
      "CTGA", "CTGC", "CTGG", "CTGT", "CTTA", "CTTC", "CTTG", "CTTT"
    )
  rn <-rownames(cat96)
  crn <- function(rn) {
    x <-unlist(strsplit(rn, ""))
    paste(x[c(2, 4, 1, 3)], collapse = "")
  }
  nrn <- lapply(rn, crn)
  rownames(cat96) <- nrn
  cat96 <- cat96[SA.96.row.order, ]
  return(cat96)
}

#' Source SignatureAnalyzer Codes.
#'
#' @param signatureanalzer.code.dir The directory which stores
#' SignatureAnalyzer program files. It must include a folder
#' named \code{INPUT_SignatureAnalyzer} and a R script named
#' \code{SignatureAnalyer.PCAWG.function.R}

SourceSignatureAnlyzerCode <-
  function(signatureanalyzer.code.dir){
    here <- getwd()
    setwd(signatureanalyzer.code.dir)
    INPUT <<- "INPUT_SignatureAnalyzer/"
    suppressWarnings(
      suppressPackageStartupMessages(
        source("SignatureAnalyzer.PCAWG.function.R")
      )
    )
    setwd(here) # This is necessary because the caller
    # as specified input and output locations
    # relative to here.
  }

#' Run SignatureAnalyzer attribution on a sa.output.rdata and its corresponding catalog file.
#'
#' Normally, please call \code{\link{SignatureAnalyzerOneRun}}
#' instead of this function.
#'
#' @param input.catalog File containing input catalog.  Columns are
#' samples (tumors), rows are signatures.  SignatureAnalyzer does
#' not care about the row names (I think) TODO(Steve): check this.
#'
#' @param read.catalog.function Function taking a file path as
#' its only argument and returning a catalog as a numeric matrix.
#'
#' @param input.rdata Rdata file containing a list "out.data"
#' with 6 entries and a matrix "sigs", which is a matrix for
#' unnormalized signatures.
#'
#' @param out.dir Directory that will be created for the output;
#' abort if it already exits.  Log files will be in
#' \code{paste0(out.dir, "/tmp")}.
#'
#' @param write.signature.function Function with first argument the
#' signatures generated by SignatureAnalyzer and second argument
#' the file to write to.
#'
#' @param input.exposures A file with the synthetic exposures used to generate
#' \code{input.catalog}; if provided here,
#' this is copied over to the output directory
#' for downstream analysis.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param overwrite If TRUE, overwrite existing output
#'
#' @return The output of SignatureAnalyzer, invisibly. This is a list
#' with five elements (named in this code, not by SignatureAnalyzer):
#' \enumerate{
#'  \item \code{signatures.W} The signature matrix
#'  \item \code{exposures.fine.tuned} The corresponding exposures
#'  \item \code{likelihood} The likelihood
#'  \item \code{evidence} -1 * the posterior probability
#'  \item \code{relevance} One for each column of the \code{signatures.W}
#'  \item \code{error} A measure of reconstruction error (?)
#' }
#'
#' @details Creates several
#'  files in \code{paste0(out.dir, "/sa.output.rdata")}. These are
#'  TODO(Steve): list the files
#'
#' @export
#'
#' @importFrom utils capture.output

RunSignatureAnalyzerAttributeOnly <-
  function(input.catalog,
           read.catalog.function,
           input.rdata,
           write.signature.function,
           out.dir,
           maxK = 30,
           tol = 1e-7,
           test.only = FALSE,
           input.exposures = NULL,
           delete.tmp.files = TRUE,
           overwrite = FALSE) {

    syn.data <- read.catalog.function(input.catalog,
                                      strict = FALSE)

    if (test.only) syn.data <- syn.data[ , 1:10]

    if (dir.exists(out.dir)) {
      if (!overwrite) stop(out.dir, " already exits")
    } else {
      dir.create(out.dir)
    }
    # TEMPORARY is a global required by SignatureAnalyzer
    TEMPORARY <<- paste0(out.dir, "/tmp/")
    if (dir.exists(TEMPORARY)) {
      if (!overwrite) stop("Directory ", TEMPORARY, " already exists")
    } else {
      dir.create(TEMPORARY)
    }

    # BayesNMF.L1W.L2H is defined by the statement
    # source("SignatureAnalyzer.PCAWG.function.R") above.
    # BayesNMF.L1W.L2H will output:
    # [[1]]: extracted signatures
    # [[2]]: RAW-attributed exposures (not finalized)
    # [[3]]: likelihood -
    # [[4]]: evidence -
    # [[5]]: relevance -
    # [[6]]: error -
    load(input.rdata) ## out.data and sigs will be loaded

    ## Output raw-extracted signatures. (Sum of each signature != 1)
    sigs <- out.data[[1]]
    sigs.to.use <- which(colSums(sigs) > 1 )
    stopifnot(length(sigs.to.use) > 0)
    sigs <- sigs[   , sigs.to.use, drop = FALSE]
    ## Normalize the mutational signatures so that the sum of all channels equal to 1.
    sigs <- apply(sigs,2,function(x) x/sum(x))
    ## Change the names of extracted signatures to W1,W2,...
    new.names <- paste0("W.", 1:ncol(sigs))
    colnames(sigs) <- new.names

    ## Output RAW-attributed exposures.
    ## NOTE: This is not the exposure SignatureAnalyzer suppose to output.
    ## After two more steps, fine-tuned attributed exposures will be provided.
    exp.raw <- out.data[[2]]
    exp.raw <- exp.raw[sigs.to.use, , drop = FALSE]
    rownames(exp.raw) <- new.names

    ## 2 more steps Fine-tuned attribution.
    ## INPUT: extracted signatures (sigs)
    ## and RAW-attributed exposures (exp.raw)
    W0 <- sigs ## Extracted signatures
    H0 <- exp.raw ## initially attributed exposures

    V0 <- syn.data     ## Catalog matrix for all tumors
    K0 <- ncol(W0)     ## # of signatures

    ## Z0 is a signature allowance matrix for the whole dataset.
    ## rows refer to signatures, columns refer to tumor samples.
    ## If you specify an entry as 0,
    ## then you prohibit a signature to be active in this tumor sample.
    ## Here, we simply select Z0 as unit matrix (all-1 matrix)
    ## and therefore any signature is allowed to be present in any tumor.
    Z0 <- array(1,dim=c(K0,ncol(V0))) ## signature indicator matrix Z (0 = not allowed, 1 = allowed); all elements initialized by one.
    colnames(Z0) <- colnames(H0)
    rownames(Z0) <- rownames(H0)

    ## The original SignatureAnalyzer code attributes tumors of different tumor types separately
    ## TODO(Wuyang): Add separation of tumor types later.
    ttype <- rep("SBS1.SBS5.correlated",ncol(V0))
    ttype.unique <- unique(ttype)
    n.ttype.unique <- length(ttype.unique)


    a0 <- 10 ### default parameter
    phi <- 1.5 ### default parameter
    for (i in 1:n.ttype.unique) {
      #### First step: determine a set of optimal signatures best explaining the observed mutations in each tumor type ("cohort").
      #### The automatic relevance determination technique was applied to the H matrix only, while keeping signatures (W0) frozen.
      cohort <- ttype.unique[i] ## each cohort is composed of tumor catalogs with the SAME tumor type.
      W1 <- W0
      V1 <- as.matrix(V0[,ttype==cohort])
      Z1 <- Z0[,match(colnames(V1),colnames(Z0),nomatch=0)] ## If a signature is not active in a tumor type in initial attribution,
      ## it is no more allowed in the fine-tuned attribution step.
      H1 <- Z1*H0[,match(colnames(V1),colnames(Z0),nomatch=0)]
      lambda <- rep(1+(sqrt((a0-1)*(a0-2)*mean(V1,na.rm=T)/K0))/(nrow(V1) + ncol(V1) + a0 + 1)*2,K0)
      res0 <- BayesNMF.L1.KL.fixed_W.Z(as.matrix(V1),as.matrix(W1),as.matrix(H1),as.matrix(Z1),lambda,2000000,a0,1.e-07,1/phi)
      H2 <- res0[[2]]  ## Attribution from second step
      colnames(H2) <- colnames(V1) ## The colnames of H2 (exposure attribution matrix) are the names of tumor samples,
      ## it should be the same as the colnames of V1 (catalog matrix for tumors whose tumor type is cohort=ttype.unique[i])
      rownames(H2) <- colnames(W0) ## The rownames of H2 (exposure attribution matrix) are the names of signatures,
      ## it should be the same as the colnames of W0 (signature matrix extracted in the previous section)

      #### Second step: determine a sample-level exposure attribution using selected sigantures in the first step.
      index.H2 <- rowSums(H2)>1 ### identify only active signatures in the cohort
      Z2 <- Z1
      Z2[!index.H2,] <- 0 ### only selected signatures in the first step are allowed + the original contraints on the signature availability from Z1.
      for (j in 1:ncol(H2)) {
        tmpH <- rep(0,ncol(W0))
        if (sum(V1[,j])>=5) {
          lambda <- 1+(sqrt((a0-1)*(a0-2)*mean(V1,na.rm=T)/K0))/(nrow(V1) + ncol(V1) + a0 + 1)*2
          res <- BayesNMF.L1.KL.fixed_W.Z.sample(as.matrix(V1[,j]),W0,as.matrix(H2[,j]),as.matrix(Z2[,j]),lambda,1000000,a0,1.e-07,1) ## Precise attribution
          tmpH <- res[[2]]
        }
        if (j==1) {
          H3 <- tmpH
        } else {
          H3 <- cbind(H3,tmpH)
          if (verbose) cat(j,'\n')
        }
      }
      colnames(H3) <- colnames(V1)
      rownames(H3) <- colnames(W0)
      if (i==1) {
        H2.all <- H2
        H3.all <- H3
      } else {
        H2.all <- cbind(H2.all,H2)  ## Attribution result from step 2
        H3.all <- cbind(H3.all,H3)  ## Attribution result from step 3
      }
    }
    exp.fine.tuned <- H3.all ### fine-tuned attributions of signature exposures




    ## List of output exposures.
    out.data[[7]] <- sigs ## Normalized sigs
    out.data[[8]] <- exp.fine.tuned ## Well-attributed exposures

    names(out.data) <- c("signatures.W", "exposures.H",
                         "likelihood", "evidence",
                         "relevance", "error",
                         "normalized.sigs","exposures.fine.tuned")

    ## Output normalized signatures
    write.signature.function(sigs,
                             paste0(out.dir, "/sa.output.sigs.csv"))
    ## Output fine-tuned attributions
    WriteExposure(exp.fine.tuned, file = paste0(out.dir, "/sa.output.exp.csv"))

    if (!is.null(input.exposures)) {
      WriteExposure(ReadExposure(input.exposures),
                    file = paste0(out.dir, "/input.syn.exp.csv"))
    }

    other.data <- paste0(out.dir, "/sa.output.other.data.csv")

    cat("num.sigs,", ncol(sigs), "\n", sep = "", file = other.data)
    cat("likelihood,", out.data$likelihood, "\n",
        sep = "", file = other.data, append = TRUE)
    cat("evidence,", out.data$evidence, "\n",
        sep = "", file = other.data, append = TRUE)
    cat("relevance,",
        paste(out.data$relevance, collapse = ","), "\n",
        sep = "", file = other.data, append = TRUE)
    cat("error,", out.data$error, "\n",
        sep = "", file = other.data, append = TRUE)

    if (delete.tmp.files) unlink(TEMPORARY, recursive = TRUE)

    invisible(out.data)
  }



#' Run SignatureAnalyzer on a file containing a catalog.
#'
#' Normally, please call \code{\link{SignatureAnalyzerOneRun}}
#' instead of this function.
#'
#' @param input.catalog File containing input catalog.  Columns are
#' samples (tumors), rows are signatures.  SignatureAnalyzer does
#' not care about the row names (I think) TODO(Steve): check this.
#'
#' @param read.catalog.function Function taking a file path as
#' its only argument and returning a catalog as a numeric matrix.
#'
#' @param out.dir Directory that will be created for the output;
#' abort if it already exits.  Log files will be in
#' \code{paste0(out.dir, "/tmp")}.
#'
#' @param write.signature.function Function with first argument the
#' signatures generated by SignatureAnalyzer and second argument
#' the file to write to.
#'
#' @param input.exposures A file with the synthetic exposures used to generate
#' \code{input.catalog}; if provided here,
#' this is copied over to the output directory
#' for downstream analysis.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param overwrite If TRUE, overwrite existing output
#'
#' @return The output of SignatureAnalyzer, invisibly. This is a list
#' with five elements (named in this code, not by SignatureAnalyzer):
#' \enumerate{
#'  \item \code{signatures.W} The signature matrix
#'  \item \code{exposures.fine.tuned} The corresponding exposures
#'  \item \code{likelihood} The likelihood
#'  \item \code{evidence} -1 * the posterior probability
#'  \item \code{relevance} One for each column of the \code{signatures.W}
#'  \item \code{error} A measure of reconstruction error (?)
#' }
#'
#' @details Creates several
#'  files in \code{paste0(out.dir, "/sa.output.rdata")}. These are
#'  TODO(Steve): list the files
#'
#' @export
#'
#' @importFrom utils capture.output

RunSignatureAnalyzerOnFile <-
  function(input.catalog,
           read.catalog.function,
           out.dir,
           write.signature.function,
           input.exposures = NULL,
           maxK = 30,
           tol = 1e-7,
           test.only = FALSE,
           delete.tmp.files = TRUE,
           overwrite = FALSE) {

    syn.data <- read.catalog.function(input.catalog,
                                      strict = FALSE)

    if (test.only) syn.data <- syn.data[ , 1:10]

    if (dir.exists(out.dir)) {
      if (!overwrite) stop(out.dir, " already exits")
    } else {
      dir.create(out.dir)
    }
    # TEMPORARY is a global required by SignatureAnalyzer
    TEMPORARY <<- paste0(out.dir, "/tmp/")
    if (dir.exists(TEMPORARY)) {
      if (!overwrite) stop("Directory ", TEMPORARY, " already exists")
    } else {
      dir.create(TEMPORARY)
    }

    suppressWarnings(
      # The suppressed warnings relate to some deprecated
      # plotting options used by SignatureAnalyzer.
      capture.output(
        # BayesNMF.L1W.L2H is defined by the statement
        # source("SignatureAnalyzer.PCAWG.function.R") above.
        # BayesNMF.L1W.L2H will output:
        # [[1]]: extracted signatures
        # [[2]]: RAW-attributed exposures (not finalized)
        # [[3]]: likelihood -
        # [[4]]: evidence -
        # [[5]]: relevance -
        # [[6]]: error -
        out.data <-
          BayesNMF.L1W.L2H(syn.data, 200000, 10, 5, tol, maxK, maxK, 1),
        file = paste0(TEMPORARY, "captured.output.txt")))

    # out.data[[1]] has raw extracted signatures; the sum of each signature != 1
    sigs.raw <- out.data[[1]]
    sigs.to.use <- which(colSums(sigs.raw) > 1 )
    stopifnot(length(sigs.to.use) > 0)
    sigs.raw <- sigs.raw[ , sigs.to.use, drop = FALSE]
    # Normalize the mutational signatures so that the sum of all channels equal
    # to 1.
    sigs <- apply(sigs.raw, 2, function(x) x/sum(x))
    # Change the names of extracted signatures to W1, W2,...
    new.names <- paste0("W.", 1:ncol(sigs))
    colnames(sigs)     <- new.names
    colnames(sigs.raw) <- new.names
    out.data[[1]] <- sigs.raw

    # exp.raw is not the exposure SignatureAnalyzer is supposed to eventually
    # output. A separate function to be called on the output from the current
    # function will compuate fine-tuned attributed exposures.
    exp.raw <- out.data[[2]]
    exp.raw <- exp.raw[sigs.to.use, , drop = FALSE]
    rownames(exp.raw) <- new.names
    out.data[[2]] <- exp.raw

    out.data[[7]] <- sigs ## Normalized sigs

    names(out.data) <- c("signatures.W", "exposures.H",
                         "likelihood", "evidence",
                         "relevance", "error",
                         "normalized.sigs")

    # Output normalized signatures
    write.signature.function(sigs,
                             paste0(out.dir, "/sa.output.sigs.csv"))

    # Output raw signatures; TODO(Steve) see if we really need these.
    write.signature.function(sigs.raw,
                             paste0(out.dir, "sa.output.raw.sigs.csv"))

    # Output raw attributions / exposures
    WriteExposure(exp.raw,
                  file = paste0(out.dir, "/sa.output.raw.exp.csv"))

    if (!is.null(input.exposures)) {
      WriteExposure(ReadExposure(input.exposures),
                    file = paste0(out.dir, "/input.syn.exp.csv"))
    }

    other.data <- paste0(out.dir, "/sa.output.other.data.csv")

    cat("num.sigs,", ncol(sigs), "\n", sep = "", file = other.data)
    cat("likelihood,", out.data$likelihood, "\n",
        sep = "", file = other.data, append = TRUE)
    cat("evidence,", out.data$evidence, "\n",
        sep = "", file = other.data, append = TRUE)
    cat("relevance,",
        paste(out.data$relevance, collapse = ","), "\n",
        sep = "", file = other.data, append = TRUE)
    cat("error,", out.data$error, "\n",
        sep = "", file = other.data, append = TRUE)

    if (delete.tmp.files) unlink(TEMPORARY, recursive = TRUE)

    invisible(out.data)
  }

########## NEXT FUNCTION TEMPORARY AS STEVE ROLLS BACK RunSignatureAnalyzerOnFile ABOVE


#' Temp version with Wu Yang's attribution code Run SignatureAnalyzer on a file containing a catalog.
#'
#' Normally, please call \code{\link{SignatureAnalyzerOneRun}}
#' instead of this function.
#'
#' @param input.catalog File containing input catalog.  Columns are
#' samples (tumors), rows are signatures.  SignatureAnalyzer does
#' not care about the row names (I think) TODO(Steve): check this.
#'
#' @param read.catalog.function Function taking a file path as
#' its only argument and returning a catalog as a numeric matrix.
#'
#' @param out.dir Directory that will be created for the output;
#' abort if it already exits.  Log files will be in
#' \code{paste0(out.dir, "/tmp")}.
#'
#' @param write.signature.function Function with first argument the
#' signatures generated by SignatureAnalyzer and second argument
#' the file to write to.
#'
#' @param input.exposures A file with the synthetic exposures used to generate
#' \code{input.catalog}; if provided here,
#' this is copied over to the output directory
#' for downstream analysis.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param overwrite If TRUE, overwrite existing output
#'
#' @return The output of SignatureAnalyzer, invisibly. This is a list
#' with five elements (named in this code, not by SignatureAnalyzer):
#' \enumerate{
#'  \item \code{signatures.W} The signature matrix
#'  \item \code{exposures.fine.tuned} The corresponding exposures
#'  \item \code{likelihood} The likelihood
#'  \item \code{evidence} -1 * the posterior probability
#'  \item \code{relevance} One for each column of the \code{signatures.W}
#'  \item \code{error} A measure of reconstruction error (?)
#' }
#'
#' @details Creates several
#'  files in \code{paste0(out.dir, "/sa.output.rdata")}. These are
#'  TODO(Steve): list the files
#'
#' @export
#'
#' @importFrom utils capture.output

TEMPRunSignatureAnalyzerOnFile <-
  function(input.catalog,
           read.catalog.function,
           out.dir,
           write.signature.function,
           input.exposures = NULL,
           maxK = 30,
           tol = 1e-7,
           test.only = FALSE,
           delete.tmp.files = TRUE,
           overwrite = FALSE) {

    syn.data <- read.catalog.function(input.catalog,
                                      strict = FALSE)

    if (test.only) syn.data <- syn.data[ , 1:10]

    if (dir.exists(out.dir)) {
      if (!overwrite) stop(out.dir, " already exits")
    } else {
      dir.create(out.dir)
    }
    # TEMPORARY is a global required by SignatureAnalyzer
    TEMPORARY <<- paste0(out.dir, "/tmp/")
    if (dir.exists(TEMPORARY)) {
      if (!overwrite) stop("Directory ", TEMPORARY, " already exists")
    } else {
      dir.create(TEMPORARY)
    }

    # suppressWarnings(
      # The suppressed warnings relate to some deprecated
      # plotting options used by SignatureAnalyzer.
      capture.output(
        # BayesNMF.L1W.L2H is defined by the statement
        # source("SignatureAnalyzer.PCAWG.function.R") above.
        # BayesNMF.L1W.L2H will output:
        # [[1]]: extracted signatures
        # [[2]]: RAW-attributed exposures (not finalized)
        # [[3]]: likelihood -
        # [[4]]: evidence -
        # [[5]]: relevance -
        # [[6]]: error -
        out.data <-
          BayesNMF.L1W.L2H(syn.data, 200000, 10, 5, tol, maxK, maxK, 1),
        file = paste0(TEMPORARY, "captured.output.txt"))

     # )

    ## Output raw-extracted signatures. (Sum of each signature != 1)
    sigs <- out.data[[1]]
    sigs.to.use <- which(colSums(sigs) > 1 )
    stopifnot(length(sigs.to.use) > 0)
    sigs <- sigs[   , sigs.to.use, drop = FALSE]
    ## Normalize the mutational signatures so that the sum of all channels equal to 1.
    sigs <- apply(sigs,2,function(x) x/sum(x))
    ## Change the names of extracted signatures to W1,W2,...
    new.names <- paste0("W.", 1:ncol(sigs))
    colnames(sigs) <- new.names

    ## Output RAW-attributed exposures.
    ## NOTE: This is not the exposure SignatureAnalyzer suppose to output.
    ## After two more steps, fine-tuned attributed exposures will be provided.
    exp.raw <- out.data[[2]]
    exp.raw <- exp.raw[sigs.to.use, , drop = FALSE]
    rownames(exp.raw) <- new.names

    # We need new code to handle the case in which there is only one signature
    if (ncol(sigs) == 1) {
      stop("The attribution code below cannot handle the case where there is only one signature")
    }

    ## 2 more steps Fine-tuned attribution.
    ## INPUT: extracted signatures (sigs)
    ## and RAW-attributed exposures (exp.raw)
    W0 <- sigs ## Extracted signatures
    H0 <- exp.raw ## initially attributed exposures

    V0 <- syn.data     ## Catalog matrix for all tumors
    K0 <- ncol(W0)     ## # of signatures

    ## Z0 is a signature allowance matrix for the whole dataset.
    ## rows refer to signatures, columns refer to tumor samples.
    ## If you specify an entry as 0,
    ## then you prohibit a signature to be active in this tumor sample.
    ## Here, we simply select Z0 as unit matrix (all-1 matrix)
    ## and therefore any signature is allowed to be present in any tumor.
    Z0 <- array(1,dim=c(K0,ncol(V0))) ## signature indicator matrix Z (0 = not allowed, 1 = allowed); all elements initialized by one.
    colnames(Z0) <- colnames(H0)
    rownames(Z0) <- rownames(H0)

    ## The original SignatureAnalyzer code attributes tumors of different tumor types separately
    ## TODO(Wuyang): Add separation of tumor types later.
    ttype <- rep("SBS1.SBS5.correlated",ncol(V0))
    ttype.unique <- unique(ttype)
    n.ttype.unique <- length(ttype.unique)


    a0 <- 10 ### default parameter
    phi <- 1.5 ### default parameter
    for (i in 1:n.ttype.unique) {
      #### First step: determine a set of optimal signatures best explaining the observed mutations in each tumor type ("cohort").
      #### The automatic relevance determination technique was applied to the H matrix only, while keeping signatures (W0) frozen.
      cohort <- ttype.unique[i] ## each cohort is composed of tumor catalogs with the SAME tumor type.
      W1 <- W0
      V1 <- as.matrix(V0[,ttype==cohort])
      Z1 <- Z0[,match(colnames(V1),colnames(Z0),nomatch=0)] ## If a signature is not active in a tumor type in initial attribution,
      ## it is no more allowed in the fine-tuned attribution step.
      H1 <- Z1*H0[,match(colnames(V1),colnames(Z0),nomatch=0)]
      lambda <- rep(1+(sqrt((a0-1)*(a0-2)*mean(V1,na.rm=T)/K0))/(nrow(V1) + ncol(V1) + a0 + 1)*2,K0)
      res0 <- BayesNMF.L1.KL.fixed_W.Z(as.matrix(V1),as.matrix(W1),as.matrix(H1),as.matrix(Z1),lambda,2000000,a0,1.e-07,1/phi)
      H2 <- res0[[2]]  ## Attribution from second step
      colnames(H2) <- colnames(V1) ## The colnames of H2 (exposure attribution matrix) are the names of tumor samples,
      ## it should be the same as the colnames of V1 (catalog matrix for tumors whose tumor type is cohort=ttype.unique[i])
      rownames(H2) <- colnames(W0) ## The rownames of H2 (exposure attribution matrix) are the names of signatures,
      ## it should be the same as the colnames of W0 (signature matrix extracted in the previous section)

      #### Second step: determine a sample-level exposure attribution using selected sigantures in the first step.
      index.H2 <- rowSums(H2)>1 ### identify only active signatures in the cohort
      Z2 <- Z1
      Z2[!index.H2,] <- 0 ### only selected signatures in the first step are allowed + the original contraints on the signature availability from Z1.
      for (j in 1:ncol(H2)) {
        tmpH <- rep(0,ncol(W0))
        if (sum(V1[,j])>=5) {
          lambda <- 1+(sqrt((a0-1)*(a0-2)*mean(V1,na.rm=T)/K0))/(nrow(V1) + ncol(V1) + a0 + 1)*2
          res <- BayesNMF.L1.KL.fixed_W.Z.sample(as.matrix(V1[,j]),W0,as.matrix(H2[,j]),as.matrix(Z2[,j]),lambda,1000000,a0,1.e-07,1) ## Precise attribution
          tmpH <- res[[2]]
        }
        if (j==1) {
          H3 <- tmpH
        } else {
          H3 <- cbind(H3,tmpH)
          if (verbose) cat(j,'\n')
        }
      }
      colnames(H3) <- colnames(V1)
      rownames(H3) <- colnames(W0)
      if (i==1) {
        H2.all <- H2
        H3.all <- H3
      } else {
        H2.all <- cbind(H2.all,H2)  ## Attribution result from step 2
        H3.all <- cbind(H3.all,H3)  ## Attribution result from step 3
      }
    }
    exp.fine.tuned <- H3.all ### fine-tuned attributions of signature exposures




    ## List of output exposures.
    out.data[[7]] <- sigs ## Normalized sigs
    out.data[[8]] <- exp.fine.tuned ## Well-attributed exposures

    names(out.data) <- c("signatures.W", "exposures.H",
                         "likelihood", "evidence",
                         "relevance", "error",
                         "normalized.sigs","exposures.fine.tuned")

    ## Output normalized signatures
    write.signature.function(sigs,
                             paste0(out.dir, "/sa.output.sigs.csv"))
    ## Output fine-tuned attributions
    WriteExposure(exp.fine.tuned, file = paste0(out.dir, "/sa.output.exp.csv"))

    if (!is.null(input.exposures)) {
      WriteExposure(ReadExposure(input.exposures),
                    file = paste0(out.dir, "/input.syn.exp.csv"))
    }

    other.data <- paste0(out.dir, "/sa.output.other.data.csv")

    cat("num.sigs,", ncol(sigs), "\n", sep = "", file = other.data)
    cat("likelihood,", out.data$likelihood, "\n",
        sep = "", file = other.data, append = TRUE)
    cat("evidence,", out.data$evidence, "\n",
        sep = "", file = other.data, append = TRUE)
    cat("relevance,",
        paste(out.data$relevance, collapse = ","), "\n",
        sep = "", file = other.data, append = TRUE)
    cat("error,", out.data$error, "\n",
        sep = "", file = other.data, append = TRUE)

    if (delete.tmp.files) unlink(TEMPORARY, recursive = TRUE)

    invisible(out.data)
  }



#' Run SignatureAnalyzer once on a single data set and put results
#' in specified location.
#'
#' @param signatureanalyzer.code.dir The directory holding the
#' SignatureAnalyzer code.
#'
#' @param input.catalog Path to the file containing the catalog
#' of mutational spectra.
#'
#' @param read.catalog.function Function to read \code{input.catalog}.
#'
#' @param out.dir Location to put the output; must not already exist; it
#' will be created.
#'
#' @param write.signature.function Function to write the extracted
#' signatures to a file.
#'
#' @param input.exposures Exposures from which the spectra in
#' \code{input.catalog} were generated.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param verbose If > 0, write some tracing and timing information.
#'
#' @param overwrite If TRUE overwrite preexisting results.
#'
#' #' @return The output of SignatureAnalyzer, invisibly. This is a list
#' with five elements (named in this code, not by SignatureAnalyzer):
#' \enumerate{
#'  \item \code{signatures.W} The signature matrix
#'  \item \code{exposures.H} The corresponding exposures
#'  \item \code{likelihood} The likelihood
#'  \item \code{evidence} -1 * the posterior probability
#'  \item \code{relevance} One for each column of the \code{signatures.W}
#'  \item \code{error} A measure of reconstruction error (?)
#' }

SignatureAnalyzerOneRun <-
  function(signatureanalyzer.code.dir,
           input.catalog,
           read.catalog.function,
           out.dir,
           write.signature.function,
           input.exposures = NULL,
           maxK = 30,
           tol = 1e-7,
           test.only = FALSE,
           delete.tmp.files = TRUE,
           verbose = 0,
           overwrite = FALSE)
{
  options( warn = 0 )
  SourceSignatureAnlyzerCode(signatureanalyzer.code.dir)

  if (verbose)
    cat("Running SignatureAnalyzerOneRun in", here, out.dir, "\n")
  retval <-
    RunSignatureAnalyzerOnFile(
      input.catalog = input.catalog,
      read.catalog.function = read.catalog.function,
      out.dir = out.dir,
      write.signature.function = write.signature.function,
      input.exposures = input.exposures,
      maxK = maxK,
      tol = tol,
      test.only = test.only,
      delete.tmp.files = delete.tmp.files,
      overwrite = overwrite)

  invisible(retval)
}

#' Run SignatureAnalyzer many times on one catalog and put results
#' in specified location.
#'
#' @param num.runs The number of times run SignatureAnalyzer on each
#' catalog (matrix of mutational spectra).
#'
#' @param signatureanalyzer.code.dir The directory holding the
#' SignatureAnalyzer code.
#'
#' @param input.catalog The catalog to analyze.
#'
#' @param read.catalog.function Function taking a file path as
#' its only argument and returning a catalog as a numeric matrix.
#'
#' @param out.dir Root of directory tree that will contain the
#' results.
#'
#' @param write.signature.function Function with first argument the
#' signatures generated by SignatureAnalyzer and second argument
#' the file to write to.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param overwrite If TRUE overwrite previous results in same directory tree.
#'
#' @param mc.cores Number of cores to use for \code{mclapply}; ignored on
#' Windows.
#'
#' @param verbose If TRUE cat a message regarding progress.
#'
#' @importFrom parallel mclapply
#'
#' @export
SAMultiRunOneCatalog <-
  function(num.runs,
           signatureanalyzer.code.dir,
           input.catalog,
           read.catalog.function,
           out.dir,
           write.signature.function,
           maxK = 30,
           tol = 1e-7,
           test.only = FALSE,
           delete.tmp.files = TRUE,
           overwrite = FALSE,
           mc.cores = 1,
           verbose = FALSE) {

    if (!dir.exists(out.dir)) dir.create(out.dir)
    else warning(out.dir, "exists, overwriting")

    RunOneIndex <- function(i) {
      out.dir2 <- paste0(out.dir, "/sa.run.", i)
      signature.analyzer.output <-
        SignatureAnalyzerOneRun(
          signatureanalyzer.code.dir = signatureanalyzer.code.dir,
          input.catalog = input.catalog,
          read.catalog.function = read.catalog.function,
          out.dir = out.dir2,
          write.signature.function = write.signature.function,
          maxK = maxK,
          tol = tol,
          test.only = test.only,
          delete.tmp.files = delete.tmp.files,
          overwrite = overwrite)
      attr(signature.analyzer.output, "message") <-
        paste0("Success for ", out.dir2)
      return(signature.analyzer.output)
    }

    mc.cores.to.use <-
      ifelse(Sys.info()["sysname"] == "Windows", 1, mc.cores)

    if (verbose) {
      cat("Using", mc.cores.to.use, " cores\n")
    }

    mc.output <-
      mclapply(1:num.runs, FUN = RunOneIndex, mc.cores = mc.cores.to.use)

    capture.output(
      print(mc.output),
      file = paste0(out.dir, "/verbose.txt"))

    attr(mc.output, "wd") <- getwd()
    attr(mc.output, "out.dir") <- out.dir
    attr(mc.output, "mc.cores") <- mc.cores.to.use
    return(mc.output)
  }

#' Run SignatureAnalyzer on 4 coordinated data sets and put results
#' in specified location.
#'
#' @details The 4 coordinated data sets are
#'
#' \enumerate{
#' \item \code{sa.sa.96}
#'
#' \item \code{sp.sp}
#'
#' \item \code{sa.sa.COMPOSITE}
#'
#' \item \code{sp.sa.COMPOSITE}
#'
#' }
#' which are described elsewhere.
#'
#'
#' @param num.runs Number of SignatureAnalyzer runs per data set.
#'
#' @param signatureanalyzer.code.dir The directory holding the
#' SignatureAnalyzer code.
#'
#' @param dir.root Root of directory tree that contains the
#' input data and to which the results will be written.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param slice Vector of integers from 1:4. Only run on the
#' corresponding data set (see Details).
#'
#' @param overwrite if TRUE overwrite preexisting results.
#'
#' @param mc.cores The number of cores to use with \code{mclapply};
#' automatically overridden to 1 on Windows.
#'
#' @export
#'
#' @importFrom ICAMS WriteCatalog ReadCatalog

SignatureAnalyzer4MatchedCatalogs <-
  function(
    num.runs = 20,
    signatureanalyzer.code.dir,
    dir.root,
    maxK = 30,
    tol = 1e-7,
    test.only = FALSE,
    delete.tmp.files = TRUE,
    slice = 1:4,
    overwrite = FALSE,
    mc.cores = 1) {

    if (!dir.exists(dir.root)) stop(dir.root, "does not exist")

    subdirs <- c("sa.sa.96", "sp.sp", "sa.sa.COMPOSITE", "sp.sa.COMPOSITE")
    read.fn <- c(ReadCatalog, ReadCatalog, ReadCatCOMPOSITE, ReadCatCOMPOSITE)
    write.fn <- c(WriteCatalog, WriteCatalog, WriteCatCOMPOSITE, WriteCatCOMPOSITE)

    tmp.fn <- function(subdir, read.fn, write.fn) {
      retval1 <-
        SAMultiRunOneCatalog(
          num.runs = num.runs,
          signatureanalyzer.code.dir = signatureanalyzer.code.dir,
          input.catalog = paste0(dir.root, "/", subdir, "/ground.truth.syn.catalog.csv"),
          read.catalog.function = read.fn,
          out.dir = paste0(dir.root, "/", subdir, "/sa.results/"),
          write.signature.function = write.fn,
          maxK = maxK,
          tol = tol,
          test.only = test.only,
          delete.tmp.files = delete.tmp.files,
          overwrite = overwrite,
          mc.cores = mc.cores)
      return(retval1)
    }

  retval2 <-
    mapply(tmp.fn, subdirs[slice], read.fn[slice], write.fn[slice])

  invisible(retval2)
  }
